{"version":3,"file":"styled-src-index-story.74920349.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8IA","sources":["webpack://charcoal-ui/./packages/styled/src/util.ts"],"sourcesContent":["import {\n  applyEffect,\n  customPropertyToken,\n  disabledSelector,\n  filterObject,\n  flatMapObject,\n  notDisabledSelector,\n} from '@charcoal-ui/utils'\nimport { CharcoalAbstractTheme, EffectType, Key } from '@charcoal-ui/theme'\nimport { CSSObject } from 'styled-components'\n\n/**\n * Function used to assert a given code path is unreachable\n */\nexport function unreachable(): never\n/**\n * Function used to assert a given code path is unreachable.\n * Very useful for ensuring switches are exhaustive:\n *\n * ```ts\n * switch (a.type) {\n *   case Types.A:\n *   case Types.B:\n *     break\n *   default:\n *     unreachable(a) // will cause a build error if there was\n *                    // a Types.C that was not checked\n * }\n * ```\n *\n * @param value Value to be asserted as unreachable\n */\n// NOTE: Uses separate overloads, _not_ `value?: never`, to not allow `undefined` to be passed\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function unreachable(value: never): never\nexport function unreachable(value?: never): never {\n  throw new Error(\n    arguments.length === 0\n      ? 'unreachable'\n      : `unreachable (${JSON.stringify(value)})`\n  )\n}\n\n/**\n * Check whether a value is non-null and non-undefined\n *\n * @param value nullable\n */\nexport const isPresent = <T>(value: T): value is NonNullable<T> => value != null\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Head<U> = U extends [infer T, ...any[]] ? T : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Tail<U> = U extends [any, any, ...any[]]\n  ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((...args: U) => any) extends (head: any, ...args: infer T) => any\n    ? T\n    : never\n  : never\n// Buggy at ts@4.0.0-dev20200506\n// type Tail<U> = U extends [any, ...infer T] ? T : never\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RecursiveObjectAssign<T, S extends any[]> = {\n  0: T & Head<S>\n  1: RecursiveObjectAssign<T & Head<S>, Tail<S>>\n}[Tail<S> extends never ? 0 : 1]\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ObjectAssign<T extends any[]> = RecursiveObjectAssign<\n  Record<string, unknown>,\n  T\n>\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function objectAssign<T extends any[]>(...sources: T) {\n  return Object.assign({}, ...sources) as ObjectAssign<T>\n}\n\n/**\n * Object.keys の返り値の型を厳しめにしてくれるやつ。\n *\n * ジェネリクスは基本的に明示して使うことを推奨。\n *\n * このライブラリでは Theme オブジェクトのジェネリクスを引き回すケースが多く、\n * ジェネリクスを省略するといつのまにか keys の返り値が `string | number | symbol` になりがちなので\n *\n * @param obj - キーを取りたいオブジェクト。ジェネリクスを省略したとき `never[]` のような使えない型が返って欲しい\n */\nexport function keyof<\n  // このジェネリクスは必須（書かないと返り値が `never[]` になる ）\n  T extends Record<never, unknown>,\n  // このジェネリクスは書かなくて良い、obj の内容から推論される（ T と矛盾してはいけない ）\n  _ extends T = T\n>(obj: _) {\n  return Object.keys(obj) as unknown as (keyof T & string)[]\n}\n\nexport interface ReadonlyArrayConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isArray(value: any): value is readonly any[]\n}\n\nexport function extractNonNullKeys<V, K extends keyof V>(obj: {\n  [key in K]: V[key]\n}) {\n  return Object.entries(obj)\n    .filter(([_, v]) => v !== null)\n    .map(([k]) => k) as { [key in K]: V[key] extends null ? never : key }[K][]\n}\n\n/**\n * 配列じゃなかったら配列にする\n */\nexport function wrapArray<T>(value: ArrayOrSingle<T>): T[] {\n  return Array.isArray(value) ? value : [value]\n}\n\nexport type ArrayOrSingle<T> = T | T[]\n\nexport const noThemeProvider = new Error(\n  '`theme` is invalid. `<ThemeProvider>` is not likely mounted.'\n)\n\ntype NonNullableCSSObject = Record<keyof CSSObject, string | number>\n\n/**\n * 子孫要素で使われるカラーテーマの CSS Variables を上書きする\n *\n * @params colorParams - 上書きしたい色の定義（ `theme.color` の一部だけ書けば良い ）\n * @params effectParams - effect の定義を上書きしたい場合は渡す（必須ではない）\n *\n * @example\n * ```tsx\n * const LocalTheme = styled.div`\n *   ${defineThemeVariables({ text1: '#ff0000' })}\n *   // `text1` is now defined as red\n *   ${theme((o) => [o.font.text1])}\n * `\n * ```\n */\nexport function defineThemeVariables(\n  colorParams: Partial<CharcoalAbstractTheme['color']>,\n  effectParams?: Partial<CharcoalAbstractTheme['effect']>\n) {\n  return function toCssObject(props: {\n    theme?: Pick<CharcoalAbstractTheme, 'effect'>\n  }): NonNullableCSSObject {\n    if (!isPresent(props.theme)) {\n      throw noThemeProvider\n    }\n\n    const colors = filterObject(colorParams, isPresent)\n\n    // flatMapObject の中で毎回 Object.entries を呼ぶのは無駄なので外で呼ぶ\n    const effects = Object.entries({\n      ...props.theme.effect,\n      ...effectParams,\n    })\n\n    return flatMapObject(colors, (colorKey, color) => [\n      [customPropertyToken(colorKey), color],\n\n      ...effects.map<[string, string]>(([effectKey, effect]) => [\n        customPropertyToken(colorKey, [effectKey]),\n        applyEffect(color, [effect]),\n      ]),\n    ])\n  }\n}\n\nexport function isSupportedEffect(effect: Key): effect is EffectType {\n  return ['hover', 'press', 'disabled'].includes(effect as string)\n}\n\nexport const variable = (value: string) => `var(${value})`\n\nexport function onEffectPseudo(effect: EffectType, css: CSSObject) {\n  return effect === 'hover'\n    ? { '&:hover': { [notDisabledSelector]: css } }\n    : effect === 'press'\n    ? { '&:active': { [notDisabledSelector]: css } }\n    : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    effect === 'disabled'\n    ? { [disabledSelector]: css }\n    : unreachable(effect)\n}\n\nexport function withPrefixes(...parts: string[]) {\n  return parts.join('-')\n}\n"],"names":[],"sourceRoot":""}