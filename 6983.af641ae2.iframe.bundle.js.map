{"version":3,"file":"6983.af641ae2.iframe.bundle.js","mappings":";;;AAkDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;;;AAIA;;;AASA;AAAA;;;;;;;;;;;;AACA;;AAYA;AAEA;;;;;;;;;;;;;AACA;AAaA;;;AACA;AAGA;;;;;;;;;;AACA;AC/EA;;;AA0BA;AAGA;;;;AACA;AAIA;;;;;;;;AACA;;;;;AAQA;;;;;;;;;;;;;;;AA6BA;;;AC3BA;;;;AAGA;AAOA;;;;;;;;;;;;;;AAAA;;;;;AAqBA;;;;AAKA;;;;;;;;;AAIA;;;;AASA;;;;;AAWA;AAAA;AAgBA;;;AAAA;ACjDA;;;;;;AAAA;;;AAMA;AAGA;AAIA;;;AAAA;AAMA;;;;;;;;;AAAA;;;AAYA;;AAaA;;;;;;;;;AAAA;;AAmBA;AAIA;;;;AC5FA;;;;;;;AAAA;;;;;;AAOA;;;AAWA;AAAA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9DA;ACkBA;AAIA;AAAA;AAIA;AAAA;AAQA;;;;AAAA;AAIA;;;AACA;AAGA;;ACwFA;;;;AAAA;AAOA;;AAIA;;AAAA;;;;;;;;;;;;;;;;;;;;AASA;;;;;;AAoBA;;;AAMA;;;AAUA;;;AAKA;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;AAMA;;;;;AAAA;AC9FA;;;;AAAA;AAOA;;;;;;;;;AAAA;AASA;;;;;;;;;;AACA;;;AAUA;;;AAUA;;;;;;;;;;;;;;;AAAA;;AAeA;AAEA;;;;;;;;;;;AAcA;;;;;;;;AD3LA;;;;AEXA;;AAsBA;;;AAEA;;;AAGA;;;;;AAKA;;;;;;;;AAxDA;AC4LA;;;;;;;;;;;;;AAIA;;AAaA;AAEA;;;;AASA;;;;;AAAA;AAiBA;;;;ACrOA;;;;;AAAA;AAOA;;;;AASA;AAAA;AAIA;AAAA;AAIA;AAAA;AAIA;;;;;AAAA;ACZA;;;AAAA;;AAOA;AAEA;AACA;;;AACA;AD3BA;;;;;;;;;;AC8CA;;;;;AAAA;AAKA;;;;;ACKA;;;;;;AAAA;ACxBA;;;ACuCA;;;;AAAA;;AAIA;;AAMA;;;AAAA;AAMA;;;;;;;;;;;AAAA;;;;AAWA;AAcA;;;AAAA;AAMA;AAAA;AAIA;AAAA;ACtGA;;AAIA;;;;;;;AAAA;;;;;;;;;AAOA;;AClBA;AAAA;;;;AACA;AAOA;AAAA;;ACbA;;AAAA;;;;AAQA;;;;;;AAQA;;AC+EA;;;;AAAA;AAOA;;;;;;;AAAA;;;;AAOA;AAaA;;;;;;;;;;;;;AAeA;;;;;AAMA;AAAA;AD/IA;;AEfA;;;;;ACsEA;;;;AAKA;AAIA;AAIA;;AAIA;;;;;;;;;;AAAA;;;;;AAUA;;AAKA;AAEA;;;;;AAQA;;;;;;;;;AAAA;;AASA;AAKA;AAAA;;;;;AD9HA;;;AA4EA;;;;;;;;AAGA;;AAgBA;AAEA;;;AAMA;;;;;;;;AAAA;AAUA;;AACA;AAIA;;;;;;;;;;AACA;;;;AAgBA;;AAAA;;;AAOA;AAAA;AAGA;;;;;AAMA;AAAA;AAIA;;;;;;;;AAUA;AAAA","sources":["webpack://charcoal-ui/../src/components/Clickable/index.tsx","webpack://charcoal-ui/../src/components/Button/index.tsx","webpack://charcoal-ui/../src/components/IconButton/index.tsx","webpack://charcoal-ui/../src/components/Radio/index.tsx","webpack://charcoal-ui/../src/components/MultiSelect/index.tsx","webpack://charcoal-ui/../src/components/Switch/index.tsx","webpack://charcoal-ui/../src/components/FieldLabel/index.tsx","webpack://charcoal-ui/../src/components/TextField/index.tsx","webpack://charcoal-ui/../src/components/TextArea/index.tsx","webpack://charcoal-ui/../src/components/Modal/Dialog/index.tsx","webpack://charcoal-ui/../src/components/Modal/index.tsx","webpack://charcoal-ui/../src/components/Modal/ModalPlumbing.tsx","webpack://charcoal-ui/../src/components/LoadingSpinner/index.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/Popover/index.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/MenuList/index.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/index.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/ListItem/index.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/DropdownMenuItem.tsx","webpack://charcoal-ui/../src/components/DropdownSelector/MenuItemGroup/index.tsx","webpack://charcoal-ui/../src/components/SegmentedControl/index.tsx","webpack://charcoal-ui/../src/components/TagItem/index.tsx","webpack://charcoal-ui/../src/components/Checkbox/index.tsx"],"sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\nimport {\n  LinkProps,\n  useComponentAbstraction,\n} from '../../core/ComponentAbstraction'\nimport { disabledSelector } from '@charcoal-ui/utils'\n\ninterface BaseProps {\n  /**\n   * クリックの無効化\n   */\n  disabled?: boolean\n}\n\ninterface LinkBaseProps {\n  /**\n   * リンクのURL。指定するとbuttonタグではなくaタグとして描画される\n   */\n  to: string\n}\n\nexport type ClickableProps =\n  | (BaseProps & Omit<React.ComponentPropsWithoutRef<'button'>, 'disabled'>)\n  | (BaseProps & LinkBaseProps & Omit<LinkProps, 'to'>)\nexport type ClickableElement = HTMLButtonElement & HTMLAnchorElement\n\nconst Clickable = React.forwardRef<ClickableElement, ClickableProps>(\n  function Clickable(props, ref) {\n    const { Link } = useComponentAbstraction()\n    const isLink = 'to' in props\n    const as = isLink ? Link : 'button'\n    const ariaDisabled = isLink && props.disabled === true ? true : undefined\n    let rest = props\n    if (isLink) {\n      const { disabled, ..._rest } = props\n      rest = _rest\n    }\n    return (\n      <StyledClickableDiv\n        {...rest}\n        ref={ref}\n        as={as}\n        aria-disabled={ariaDisabled}\n      />\n    )\n  }\n)\nexport default Clickable\n\nconst StyledClickableDiv = styled.div`\n  cursor: pointer;\n\n  ${disabledSelector} {\n    cursor: default;\n  }\n\n  /* Reset button appearance */\n  appearance: none;\n  background: transparent;\n  padding: 0;\n  border-style: none;\n  outline: none;\n  color: inherit;\n  text-rendering: inherit;\n  letter-spacing: inherit;\n  word-spacing: inherit;\n  text-decoration: none;\n\n  &:focus {\n    outline: none;\n  }\n\n  /* Change the font styles in all browsers. */\n  font: inherit;\n\n  /* Remove the margin in Firefox and Safari. */\n  margin: 0;\n\n  /* Show the overflow in Edge. */\n  overflow: visible;\n\n  /* Remove the inheritance of text transform in Firefox. */\n  text-transform: none;\n\n  /* Remove the inner border and padding in Firefox. */\n  &::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n`\n","import { forwardRef } from 'react'\nimport styled, { css } from 'styled-components'\nimport { unreachable } from '../../_lib'\nimport Clickable, { ClickableElement, ClickableProps } from '../Clickable'\n\ntype Variant = 'Primary' | 'Default' | 'Overlay' | 'Danger' | 'Navigation'\ntype Size = 'S' | 'M'\n\ninterface StyledProps {\n  $variant: Variant\n  $fullWidth: boolean\n  $size: Size\n}\n\nexport type ButtonProps = Partial<{\n  variant: Variant\n  size: Size\n  fullWidth: boolean\n}> &\n  ClickableProps\n\nconst Button = forwardRef<ClickableElement, ButtonProps>(function Button(\n  {\n    children,\n    variant = 'Default',\n    size = 'M',\n    fullWidth: fixed = false,\n    disabled = false,\n    ...rest\n  },\n  ref\n) {\n  return (\n    <StyledButton\n      {...rest}\n      disabled={disabled}\n      $background={variantToBackground(variant)}\n      $color={variantToFont(variant)}\n      $size={size}\n      $fullWidth={fixed}\n      ref={ref}\n    >\n      {children}\n    </StyledButton>\n  )\n})\nexport default Button\n\nconst horizontalPaddingSmall = css`\n  padding-right: 16px;\n  padding-left: 16px;\n`\nconst horizontalPaddingMedium = css`\n  padding-right: 24px;\n  padding-left: 24px;\n`\n\ntype StyledButtonProps = Omit<StyledProps, '$variant'> & {\n  $background: ReturnType<typeof variantToBackground>\n  $color: ReturnType<typeof variantToFont>\n}\nconst StyledButton = styled(Clickable)<StyledButtonProps>`\n  width: ${(p) => (p.$fullWidth ? 'stretch' : 'min-content')};\n  display: inline-grid;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  user-select: none;\n  white-space: nowrap;\n  border-radius: 999999px;\n  font-size: 14px;\n  line-height: 22px;\n  font-weight: bold;\n\n  ${(p) => (p.$size === 'M' ? horizontalPaddingMedium : horizontalPaddingSmall)}\n\n  color: var(--charcoal-${(p) => p.$color});\n  background-color: var(--charcoal-${(p) => p.$background});\n  transition: 0.2s color, 0.2s background-color, 0.2s box-shadow;\n\n  &:not(:disabled):not([aria-disabled]),\n  &[aria-disabled='false'] {\n    &:active,\n    &:focus,\n    &:focus-visible {\n      outline: none;\n      box-shadow: 0 0 0 4px rgba(0, 150, 250, 0.32);\n    }\n\n    &:hover {\n      color: var(--charcoal-${(p) => p.$color}-hover);\n      background-color: var(--charcoal-${(p) => p.$background}-hover);\n    }\n    &:active {\n      color: var(--charcoal-${(p) => p.$color}-press);\n      background-color: var(--charcoal-${(p) => p.$background}-press);\n    }\n  }\n\n  &:disabled,\n  &[aria-disabled]:not([aria-disabled='false']) {\n    opacity: 0.32;\n  }\n\n  /* よく考えたらheight=32って定義が存在しないな... */\n  height: ${(p) => (p.$size === 'M' ? 40 : 32)}px;\n`\n\nfunction variantToBackground(variant: Variant) {\n  switch (variant) {\n    case 'Overlay':\n      return 'surface4'\n    case 'Default':\n      return 'surface3'\n    case 'Primary':\n      return 'brand'\n    case 'Navigation':\n      return 'surface6'\n    case 'Danger':\n      return 'assertive'\n    default:\n      return unreachable(variant)\n  }\n}\n\nfunction variantToFont(variant: Variant) {\n  switch (variant) {\n    case 'Overlay':\n      return 'text5'\n    case 'Default':\n      return 'text2'\n    case 'Primary':\n      return 'text5'\n    case 'Navigation':\n      return 'text5'\n    case 'Danger':\n      return 'text5'\n    default:\n      return unreachable(variant)\n  }\n}\n","import { forwardRef } from 'react'\nimport styled from 'styled-components'\nimport Clickable, { ClickableElement, ClickableProps } from '../Clickable'\nimport type { KnownIconType } from '@charcoal-ui/icons'\n\ntype Variant = 'Default' | 'Overlay'\ntype Size = 'XS' | 'S' | 'M'\n\ninterface StyledProps {\n  readonly variant?: Variant\n  readonly size?: Size\n  readonly icon: keyof KnownIconType\n}\n\nexport type IconButtonProps = StyledProps & ClickableProps\n\nconst IconButton = forwardRef<ClickableElement, IconButtonProps>(\n  function IconButtonInner(\n    { variant = 'Default', size = 'M', icon, ...rest }: IconButtonProps,\n    ref\n  ) {\n    validateIconSize(size, icon)\n    return (\n      <StyledIconButton {...rest} ref={ref} $size={size} $variant={variant}>\n        <pixiv-icon name={icon} />\n      </StyledIconButton>\n    )\n  }\n)\n\nexport default IconButton\n\ntype StyledIconButtonProps = Required<{\n  [key in keyof Pick<\n    StyledProps,\n    'size' | 'variant'\n  > as `$${key}`]: StyledProps[key]\n}>\n\nconst StyledIconButton = styled(Clickable).attrs<\n  StyledIconButtonProps,\n  ReturnType<typeof styledProps>\n>(styledProps)<StyledIconButtonProps>`\n  user-select: none;\n\n  width: ${(p) => p.$width}px;\n  height: ${(p) => p.$height}px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(${({ $font }) => `--charcoal-${$font}`});\n  background-color: var(${({ $background }) => `--charcoal-${$background}`});\n  border-radius: 999999px;\n  transition: 0.2s background-color, 0.2s box-shadow;\n\n  &:not(:disabled):not([aria-disabled]),\n  &[aria-disabled='false'] {\n    &:hover {\n      background-color: var(\n        ${({ $background }) => `--charcoal-${$background}-hover`}\n      );\n    }\n    &:active {\n      background-color: var(\n        ${({ $background }) => `--charcoal-${$background}-press`}\n      );\n    }\n    &:focus,\n    &:active,\n    &:focus-visible {\n      outline: none;\n      box-shadow: 0 0 0 4px rgba(0, 150, 250, 0.32);\n    }\n  }\n\n  &:disabled,\n  &[aria-disabled]:not([aria-disabled='false']) {\n    opacity: 0.32;\n  }\n`\n\nfunction styledProps({ $size, $variant }: StyledIconButtonProps) {\n  return {\n    ...variantToProps($variant),\n    ...sizeToProps($size),\n  }\n}\n\nfunction variantToProps(variant: Variant) {\n  switch (variant) {\n    case 'Default':\n      return { $font: 'text3', $background: 'transparent' } as const\n    case 'Overlay':\n      return { $font: 'text5', $background: 'surface4' } as const\n  }\n}\n\nfunction sizeToProps(size: Size) {\n  switch (size) {\n    case 'XS':\n      return {\n        $width: 20,\n        $height: 20,\n      }\n    case 'S':\n      return {\n        $width: 32,\n        $height: 32,\n      }\n    case 'M':\n      return {\n        $width: 40,\n        $height: 40,\n      }\n  }\n}\n\n/**\n * validates matches of size and icon\n */\nfunction validateIconSize(size: Size, icon: keyof KnownIconType) {\n  let requiredIconSize: string\n  switch (size) {\n    case 'XS':\n      requiredIconSize = '16'\n      break\n    case 'S':\n    case 'M':\n      requiredIconSize = '24'\n      break\n  }\n  // アイコン名は サイズ/名前\n  const result = /^\\d*/u.exec(icon)\n  if (result == null) {\n    throw new Error('Invalid icon name')\n  }\n  const [iconSize] = result\n  if (iconSize !== requiredIconSize) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `IconButton with size \"${size}\" expect icon size \"${requiredIconSize}, but got \"${iconSize}\"`\n    )\n  }\n}\n","import { memo, forwardRef, useCallback, useContext } from 'react'\nimport * as React from 'react'\nimport styled from 'styled-components'\nimport warning from 'warning'\nimport { theme } from '../../styled'\nimport { px } from '@charcoal-ui/utils'\n\nexport type RadioProps = React.PropsWithChildren<{\n  value: string\n  disabled?: boolean\n  className?: string\n}>\n\nconst Radio = forwardRef<HTMLInputElement, RadioProps>(function RadioInner(\n  { value, disabled = false, children, className },\n  ref\n) {\n  const {\n    name,\n    selected,\n    disabled: isParentDisabled,\n    readonly,\n    invalid,\n    onChange,\n  } = useContext(RadioGroupContext)\n\n  warning(\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    name !== undefined,\n    `\"name\" is not Provided for <Radio>. Perhaps you forgot to wrap with <RadioGroup> ?`\n  )\n\n  const isSelected = value === selected\n  const isDisabled = disabled || isParentDisabled\n  const isReadonly = readonly && !isSelected\n\n  const handleChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      onChange(e.currentTarget.value)\n    },\n    [onChange]\n  )\n\n  return (\n    <RadioRoot aria-disabled={isDisabled || isReadonly} className={className}>\n      <RadioInput\n        name={name}\n        value={value}\n        checked={isSelected}\n        invalid={invalid}\n        onChange={handleChange}\n        disabled={isDisabled || isReadonly}\n        ref={ref}\n      />\n      {children != null && <RadioLabel>{children}</RadioLabel>}\n    </RadioRoot>\n  )\n})\n\nexport default memo(Radio)\n\nconst RadioRoot = styled.label`\n  display: grid;\n  grid-template-columns: auto 1fr;\n  grid-gap: ${({ theme }) => px(theme.spacing[4])};\n  align-items: center;\n  cursor: pointer;\n\n  ${theme((o) => [o.disabled])}\n`\n\nexport const RadioInput = styled.input.attrs({ type: 'radio' })<{\n  invalid?: boolean\n}>`\n  /** Make prior to browser default style */\n  &[type='radio'] {\n    appearance: none;\n    display: block;\n    box-sizing: border-box;\n\n    margin: 0;\n    padding: 6px;\n\n    width: 20px;\n    height: 20px;\n    cursor: pointer;\n\n    ${({ invalid = false }) =>\n      theme((o) => [\n        o.borderRadius('oval'),\n        o.bg.surface1.hover.press,\n        invalid && o.outline.assertive,\n      ])};\n\n    &:not(:checked) {\n      border-width: 2px;\n      border-style: solid;\n      border-color: ${({ theme }) => theme.color.text3};\n    }\n\n    &:checked {\n      ${theme((o) => o.bg.brand.hover.press)}\n\n      &::after {\n        content: '';\n        display: block;\n        width: 8px;\n        height: 8px;\n        pointer-events: none;\n\n        ${theme((o) => [o.bg.text5.hover.press, o.borderRadius('oval')])}\n      }\n    }\n\n    ${theme((o) => o.outline.default.focus)}\n\n    /* FIXME: o.outline.default.focus の transition に o.bg.brand の transition が打ち消されてしまう */\n    transition: all 0.2s !important;\n  }\n`\n\nconst RadioLabel = styled.div`\n  ${theme((o) => [o.typography(14), o.font.text2])}\n`\n\nexport type RadioGroupProps = React.PropsWithChildren<{\n  className?: string\n  value?: string\n  label: string\n  name: string\n  onChange(next: string): void\n  disabled?: boolean\n  readonly?: boolean\n  invalid?: boolean\n}>\n\n// TODO: use (or polyfill) flex gap\nconst StyledRadioGroup = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-gap: ${({ theme }) => px(theme.spacing[8])};\n`\n\ninterface RadioGroupContext {\n  name: string\n  selected?: string\n  disabled: boolean\n  readonly: boolean\n  invalid: boolean\n  onChange: (next: string) => void\n}\n\nconst RadioGroupContext = React.createContext<RadioGroupContext>({\n  name: undefined as never,\n  selected: undefined,\n  disabled: false,\n  readonly: false,\n  invalid: false,\n  onChange() {\n    throw new Error(\n      'Cannot find onChange() handler. Perhaps you forgot to wrap with <RadioGroup> ?'\n    )\n  },\n})\n\nexport function RadioGroup({\n  className,\n  value,\n  label,\n  name,\n  onChange,\n  disabled,\n  readonly,\n  invalid,\n  children,\n}: RadioGroupProps) {\n  const handleChange = useCallback(\n    (next: string) => {\n      onChange(next)\n    },\n    [onChange]\n  )\n\n  return (\n    <RadioGroupContext.Provider\n      value={{\n        name,\n        selected: value,\n        disabled: disabled ?? false,\n        readonly: readonly ?? false,\n        invalid: invalid ?? false,\n        onChange: handleChange,\n      }}\n    >\n      <StyledRadioGroup\n        role=\"radiogroup\"\n        aria-orientation=\"vertical\"\n        aria-label={label}\n        aria-invalid={invalid}\n        className={className}\n      >\n        {children}\n      </StyledRadioGroup>\n    </RadioGroupContext.Provider>\n  )\n}\n","import { ChangeEvent, useCallback, useContext, forwardRef, memo } from 'react'\nimport * as React from 'react'\nimport styled, { css } from 'styled-components'\nimport warning from 'warning'\nimport { theme } from '../../styled'\nimport { disabledSelector, px } from '@charcoal-ui/utils'\n\nimport { MultiSelectGroupContext } from './context'\n\nexport type MultiSelectProps = React.PropsWithChildren<{\n  value: string\n  disabled?: boolean\n  variant?: 'default' | 'overlay'\n  className?: string\n  onChange?: (payload: { value: string; selected: boolean }) => void\n}>\n\nconst MultiSelect = forwardRef<HTMLInputElement, MultiSelectProps>(\n  function MultiSelectInner(\n    {\n      value,\n      disabled = false,\n      onChange,\n      variant = 'default',\n      className,\n      children,\n    },\n    ref\n  ) {\n    const {\n      name,\n      selected,\n      disabled: parentDisabled,\n      readonly,\n      invalid,\n      onChange: parentOnChange,\n    } = useContext(MultiSelectGroupContext)\n\n    warning(\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      name !== undefined,\n      `\"name\" is not Provided for <MultiSelect>. Perhaps you forgot to wrap with <MultiSelectGroup> ?`\n    )\n\n    const isSelected = selected.includes(value)\n    const isDisabled = disabled || parentDisabled || readonly\n\n    const handleChange = useCallback(\n      (event: ChangeEvent<HTMLInputElement>) => {\n        if (!(event.currentTarget instanceof HTMLInputElement)) {\n          return\n        }\n        if (onChange) onChange({ value, selected: event.currentTarget.checked })\n        parentOnChange({ value, selected: event.currentTarget.checked })\n      },\n      [onChange, parentOnChange, value]\n    )\n\n    return (\n      <MultiSelectRoot aria-disabled={isDisabled} className={className}>\n        <MultiSelectInput\n          {...{\n            name,\n            value,\n            invalid,\n          }}\n          checked={isSelected}\n          disabled={isDisabled}\n          onChange={handleChange}\n          overlay={variant === 'overlay'}\n          aria-invalid={invalid}\n          ref={ref}\n        />\n        <MultiSelectInputOverlay\n          overlay={variant === 'overlay'}\n          invalid={invalid}\n          aria-hidden={true}\n        >\n          <pixiv-icon name=\"24/Check\" unsafe-non-guideline-scale={16 / 24} />\n        </MultiSelectInputOverlay>\n        {Boolean(children) && <MultiSelectLabel>{children}</MultiSelectLabel>}\n      </MultiSelectRoot>\n    )\n  }\n)\n\nexport default memo(MultiSelect)\n\nconst MultiSelectRoot = styled.label`\n  display: grid;\n  grid-template-columns: auto 1fr;\n  align-items: center;\n  position: relative;\n  cursor: pointer;\n  ${disabledSelector} {\n    cursor: default;\n  }\n  gap: ${({ theme }) => px(theme.spacing[4])};\n  ${theme((o) => o.disabled)}\n`\n\nconst MultiSelectLabel = styled.div`\n  display: flex;\n  align-items: center;\n  ${theme((o) => [o.typography(14), o.font.text2])}\n`\n\nconst MultiSelectInput = styled.input.attrs({ type: 'checkbox' })<{\n  invalid: boolean\n  overlay: boolean\n}>`\n  &[type='checkbox'] {\n    appearance: none;\n    display: block;\n    width: 20px;\n    height: 20px;\n    margin: 0;\n\n    &:checked {\n      ${theme((o) => o.bg.brand.hover.press)}\n    }\n\n    ${({ invalid, overlay }) =>\n      theme((o) => [\n        o.bg.text3.hover.press,\n        o.borderRadius('oval'),\n        invalid && !overlay && o.outline.assertive,\n        overlay && o.bg.surface4,\n      ])};\n  }\n`\n\nconst MultiSelectInputOverlay = styled.div<{\n  overlay: boolean\n  invalid: boolean\n}>`\n  position: absolute;\n  top: -2px;\n  left: -2px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  ${({ invalid, overlay }) =>\n    theme((o) => [\n      o.width.px(24),\n      o.height.px(24),\n      o.borderRadius('oval'),\n      o.font.text5,\n      invalid && overlay && o.outline.assertive,\n    ])}\n\n  ${({ overlay }) =>\n    overlay &&\n    css`\n      border-color: ${({ theme }) => theme.color.text5};\n      border-width: 2px;\n      border-style: solid;\n    `}\n`\n\nexport type MultiSelectGroupProps = React.PropsWithChildren<{\n  className?: string\n  name: string\n  label: string\n  selected: string[]\n  onChange: (selected: string[]) => void\n  disabled?: boolean\n  readonly?: boolean\n  invalid?: boolean\n}>\n\nexport function MultiSelectGroup({\n  className,\n  name,\n  label,\n  selected,\n  onChange,\n  disabled = false,\n  readonly = false,\n  invalid = false,\n  children,\n}: MultiSelectGroupProps) {\n  const handleChange = useCallback(\n    (payload: { value: string; selected: boolean }) => {\n      const index = selected.indexOf(payload.value)\n\n      if (payload.selected) {\n        if (index < 0) {\n          onChange([...selected, payload.value])\n        }\n      } else {\n        if (index >= 0) {\n          onChange([...selected.slice(0, index), ...selected.slice(index + 1)])\n        }\n      }\n    },\n    [onChange, selected]\n  )\n\n  return (\n    <MultiSelectGroupContext.Provider\n      value={{\n        name,\n        selected: Array.from(new Set(selected)),\n        disabled,\n        readonly,\n        invalid,\n        onChange: handleChange,\n      }}\n    >\n      <div className={className} aria-label={label} data-testid=\"SelectGroup\">\n        {children}\n      </div>\n    </MultiSelectGroupContext.Provider>\n  )\n}\n","import { useSwitch } from '@react-aria/switch'\nimport type { AriaSwitchProps } from '@react-types/switch'\nimport { useMemo, memo, forwardRef } from 'react'\nimport * as React from 'react'\nimport { useToggleState } from 'react-stately'\nimport styled from 'styled-components'\nimport { theme } from '../../styled'\nimport { disabledSelector } from '@charcoal-ui/utils'\nimport { useObjectRef } from '@react-aria/utils'\n\nexport type SwitchProps = {\n  name: string\n  className?: string\n  value?: string\n  checked?: boolean\n  disabled?: boolean\n  onChange(checked: boolean): void\n} & (\n  | // children か label は片方が必須\n  {\n      children: React.ReactNode\n    }\n  | {\n      label: string\n    }\n)\n\nconst SwitchCheckbox = forwardRef<HTMLInputElement, SwitchProps>(\n  function SwitchCheckboxInner(props, external) {\n    const { disabled, className } = props\n\n    const ariaSwitchProps: AriaSwitchProps = useMemo(\n      () => ({\n        ...props,\n\n        // children がいない場合は aria-label をつけないといけない\n        'aria-label': 'children' in props ? undefined : props.label,\n        isDisabled: props.disabled,\n        isSelected: props.checked,\n      }),\n      [props]\n    )\n\n    const state = useToggleState(ariaSwitchProps)\n    const ref = useObjectRef<HTMLInputElement>(external)\n    const {\n      inputProps: { className: _className, type: _type, ...rest },\n    } = useSwitch(ariaSwitchProps, state, ref)\n\n    return (\n      <Label className={className} aria-disabled={disabled}>\n        <SwitchInput {...rest} ref={ref} />\n        {'children' in props ? (\n          // eslint-disable-next-line react/destructuring-assignment\n          <LabelInner>{props.children}</LabelInner>\n        ) : undefined}\n      </Label>\n    )\n  }\n)\n\nexport default memo(SwitchCheckbox)\n\nconst Label = styled.label`\n  display: inline-grid;\n  grid-template-columns: auto 1fr;\n  align-items: center;\n  cursor: pointer;\n  outline: 0;\n\n  ${theme((o) => o.disabled)}\n\n  :active > input {\n    box-shadow: 0 0 0 4px rgba(0, 150, 250, 0.32);\n  }\n\n  ${disabledSelector} {\n    cursor: default;\n  }\n`\n\nconst LabelInner = styled.div`\n  ${theme((o) => [\n    o.typography(14).preserveHalfLeading,\n    o.font.text2,\n    o.margin.left(4),\n  ])}\n`\n\nconst SwitchInput = styled.input.attrs({\n  type: 'checkbox',\n})`\n  appearance: none;\n  display: inline-flex;\n  position: relative;\n  box-sizing: border-box;\n  width: 28px;\n  border: 2px solid transparent;\n\n  transition-property: background-color, box-shadow;\n  transition-duration: 0.2s;\n  cursor: inherit;\n\n  outline: none;\n  border-radius: 16px;\n  height: 16px;\n  margin: 0;\n  background-color: var(--charcoal-text4);\n  :hover {\n    background-color: var(--charcoal-text4-hover);\n  }\n  :active {\n    background-color: var(--charcoal-text4-press);\n  }\n  :focus {\n    box-shadow: 0 0 0 4px rgba(0, 150, 250, 0.32);\n  }\n\n  &::after {\n    content: '';\n    position: absolute;\n    display: block;\n    top: 0;\n    left: 0;\n    width: 12px;\n    height: 12px;\n    transform: translateX(0);\n    transition: transform 0.2s;\n    border-radius: 1024px;\n    background-color: var(--charcoal-text5);\n    :hover {\n      background-color: var(--charcoal-text5-hover);\n    }\n    :active {\n      background-color: var(--charcoal-text5-press);\n    }\n  }\n\n  &:checked {\n    background-color: var(--charcoal-brand);\n    :hover {\n      background-color: var(--charcoal-brand-hover);\n    }\n    :active {\n      background-color: var(--charcoal-brand-press);\n    }\n    &::after {\n      transform: translateX(12px);\n      transition: transform 0.2s;\n    }\n  }\n`\n","import * as React from 'react'\nimport styled from 'styled-components'\nimport { createTheme } from '@charcoal-ui/styled'\n\nexport interface FieldLabelProps\n  extends React.LabelHTMLAttributes<HTMLLabelElement> {\n  readonly className?: string\n  readonly label: string\n  readonly subLabel?: React.ReactNode\n  readonly required?: boolean\n  // TODO: 翻訳用のContextで注入する\n  readonly requiredText?: string\n}\n\nconst FieldLabel = React.forwardRef<HTMLLabelElement, FieldLabelProps>(\n  function FieldLabel(\n    {\n      style,\n      className,\n      label,\n      required = false,\n      requiredText,\n      subLabel,\n      ...labelProps\n    },\n    ref\n  ) {\n    return (\n      <FieldLabelWrapper style={style} className={className}>\n        <Label ref={ref} {...labelProps}>\n          {label}\n        </Label>\n        {required && <RequiredText>{requiredText}</RequiredText>}\n        <SubLabelClickable>\n          <span>{subLabel}</span>\n        </SubLabelClickable>\n      </FieldLabelWrapper>\n    )\n  }\n)\n\nexport default FieldLabel\n\nconst theme = createTheme(styled)\n\nconst Label = styled.label`\n  ${theme((o) => [o.typography(14).bold, o.font.text1])}\n`\n\nconst RequiredText = styled.span`\n  ${theme((o) => [o.typography(14), o.font.text2])}\n`\n\nconst SubLabelClickable = styled.div`\n  ${theme((o) => [\n    o.typography(14),\n    o.font.text3.hover.press,\n    o.outline.default.focus,\n  ])}\n`\n\nconst FieldLabelWrapper = styled.div`\n  display: inline-flex;\n  align-items: center;\n\n  > ${RequiredText} {\n    ${theme((o) => o.margin.left(4))}\n  }\n\n  > ${SubLabelClickable} {\n    ${theme((o) => o.margin.left('auto'))}\n  }\n`\n","import { useTextField } from '@react-aria/textfield'\nimport { useVisuallyHidden } from '@react-aria/visually-hidden'\nimport { ReactNode, useCallback, useEffect, useRef, useState } from 'react'\nimport * as React from 'react'\nimport styled, { css } from 'styled-components'\nimport FieldLabel, { FieldLabelProps } from '../FieldLabel'\nimport { countCodePointsInString, mergeRefs } from '../../_lib'\nimport { ReactAreaUseTextFieldCompat } from '../../_lib/compat'\nimport { useFocusWithClick } from './useFocusWithClick'\n\ntype DOMProps = Omit<\n  React.InputHTMLAttributes<HTMLInputElement>,\n  // react-ariaのhookは、onChangeが`(v: string) => void`想定\n  | 'onChange'\n\n  // RDFa Attributeとかぶる\n  // https://github.com/DefinitelyTyped/DefinitelyTyped/blob/58d57ca87ac7be0d306c0844dc254e90c150bd0d/types/react/index.d.ts#L1951\n  | 'prefix'\n\n  // ReactAreaUseTextFieldCompatに書いてあるような事情で、ここにあるイベントハンドラの型をゆるめる\n  | keyof ReactAreaUseTextFieldCompat\n>\n\nexport interface TextFieldProps\n  extends Pick<FieldLabelProps, 'label' | 'requiredText' | 'subLabel'>,\n    DOMProps,\n    ReactAreaUseTextFieldCompat {\n  readonly prefix?: ReactNode\n  readonly suffix?: ReactNode\n\n  // <input> 要素は number とか string[] もありうるが、今はこれしか想定してない\n  readonly defaultValue?: string\n  readonly value?: string\n  readonly onChange?: (value: string) => void\n\n  // react-ariaの型定義のせいでHTMLInputElementにできない\n  readonly onKeyDown?: (event: React.KeyboardEvent<Element>) => void\n  readonly onFocus?: (event: React.FocusEvent<Element>) => void\n  readonly onBlur?: (event: React.FocusEvent<Element>) => void\n\n  readonly showCount?: boolean\n  readonly showLabel?: boolean\n  readonly assistiveText?: string\n  readonly invalid?: boolean\n}\n\nconst TextField = React.forwardRef<HTMLInputElement, TextFieldProps>(\n  function SingleLineTextFieldInner({ onChange, ...props }, forwardRef) {\n    const {\n      className,\n      showLabel = false,\n      showCount = false,\n      label,\n      requiredText,\n      subLabel,\n      disabled = false,\n      required,\n      invalid = false,\n      assistiveText,\n      maxLength,\n      prefix = null,\n      suffix = null,\n    } = props\n\n    const { visuallyHiddenProps } = useVisuallyHidden()\n    const ariaRef = useRef<HTMLInputElement>(null)\n    const [count, setCount] = useState(\n      countCodePointsInString(props.value ?? '')\n    )\n\n    const nonControlled = props.value === undefined\n    const handleChange = useCallback(\n      (value: string) => {\n        const count = countCodePointsInString(value)\n        if (maxLength !== undefined && count > maxLength) {\n          return\n        }\n        if (nonControlled) {\n          setCount(count)\n        }\n        onChange?.(value)\n      },\n      [maxLength, nonControlled, onChange]\n    )\n\n    useEffect(() => {\n      setCount(countCodePointsInString(props.value ?? ''))\n    }, [props.value])\n\n    const { inputProps, labelProps, descriptionProps, errorMessageProps } =\n      useTextField(\n        {\n          inputElementType: 'input',\n          isDisabled: disabled,\n          isRequired: required,\n          validationState: invalid ? 'invalid' : 'valid',\n          description: !invalid && assistiveText,\n          errorMessage: invalid && assistiveText,\n          onChange: handleChange,\n          ...props,\n        },\n        ariaRef\n      )\n\n    const containerRef = useRef(null)\n\n    useFocusWithClick(containerRef, ariaRef)\n\n    return (\n      <TextFieldRoot className={className} isDisabled={disabled}>\n        <TextFieldLabel\n          label={label}\n          requiredText={requiredText}\n          required={required}\n          subLabel={subLabel}\n          {...labelProps}\n          {...(!showLabel ? visuallyHiddenProps : {})}\n        />\n        <StyledInputContainer\n          ref={containerRef}\n          invalid={invalid}\n          aria-disabled={disabled === true ? true : undefined}\n          hasPrefix={prefix != null}\n          hasSuffix={suffix != null || showCount}\n        >\n          {prefix && <PrefixContainer>{prefix}</PrefixContainer>}\n          <StyledInput\n            ref={mergeRefs(forwardRef, ariaRef)}\n            invalid={invalid}\n            {...inputProps}\n          />\n          {(suffix || showCount) && (\n            <SuffixContainer>\n              {suffix}\n              {showCount && (\n                <SingleLineCounter>\n                  {maxLength !== undefined ? `${count}/${maxLength}` : count}\n                </SingleLineCounter>\n              )}\n            </SuffixContainer>\n          )}\n        </StyledInputContainer>\n        {assistiveText != null && assistiveText.length !== 0 && (\n          <AssistiveText\n            invalid={invalid}\n            {...(invalid ? errorMessageProps : descriptionProps)}\n          >\n            {assistiveText}\n          </AssistiveText>\n        )}\n      </TextFieldRoot>\n    )\n  }\n)\n\nexport default TextField\n\nconst TextFieldRoot = styled.div<{ isDisabled: boolean }>`\n  display: flex;\n  flex-direction: column;\n\n  ${(p) => p.isDisabled && { opacity: p.theme.elementEffect.disabled.opacity }}\n`\n\nexport const TextFieldLabel = styled(FieldLabel)`\n  margin-bottom: 8px;\n`\n\nconst StyledInputContainer = styled.div<{\n  invalid: boolean\n  hasPrefix: boolean\n  hasSuffix: boolean\n}>`\n  display: grid;\n  grid-template-columns: ${(p) =>\n    [p.hasPrefix && 'auto', '1fr', p.hasSuffix && 'auto']\n      .filter(Boolean)\n      .join(' ')};\n  height: 40px;\n  transition: 0.2s background-color, 0.2s box-shadow;\n  color: var(--charcoal-text2);\n  background-color: var(--charcoal-surface3);\n  border-radius: 4px;\n  gap: 4px;\n  padding: 0 8px;\n  line-height: 22px;\n  font-size: 14px;\n\n  :not(:disabled):not([aria-disabled]):hover,\n  [aria-disabled='false']:hover {\n    background-color: var(--charcoal-surface3-hover);\n  }\n\n  :not(:disabled):not([aria-disabled]):active,\n  [aria-disabled='false']:active {\n    outline: none;\n    box-shadow: 0 0 0 4px\n      ${(p) => (p.invalid ? `rgba(255,43,0,0.32)` : `rgba(0, 150, 250, 0.32);`)};\n  }\n\n  :focus-within {\n    outline: none;\n    box-shadow: 0 0 0 4px\n      ${(p) => (p.invalid ? `rgba(255,43,0,0.32)` : `rgba(0, 150, 250, 0.32);`)};\n  }\n\n  ${(p) =>\n    p.invalid &&\n    css`\n      box-shadow: 0 0 0 4px rgba(255, 43, 0, 0.32);\n    `}\n`\n\nconst PrefixContainer = styled.div`\n  display: flex;\n  align-items: center;\n`\n\nconst SuffixContainer = styled.span`\n  display: flex;\n  align-items: center;\n  gap: 8px;\n`\n\nconst StyledInput = styled.input<{\n  invalid: boolean\n}>`\n  border: none;\n  box-sizing: border-box;\n  outline: none;\n  font-family: inherit;\n\n  /* Prevent zooming for iOS Safari */\n  transform-origin: top left;\n  transform: scale(0.875);\n  width: calc(100% / 0.875);\n  height: calc(100% / 0.875);\n  font-size: calc(14px / 0.875);\n  line-height: calc(22px / 0.875);\n  padding-left: 0;\n  padding-right: 0;\n  border-radius: calc(4px / 0.875);\n\n  /* Display box-shadow for iOS Safari */\n  appearance: none;\n  background: transparent;\n\n  color: var(--charcoal-text2);\n  &::placeholder {\n    color: var(--charcoal-text3);\n  }\n`\n\nconst SingleLineCounter = styled.span`\n  line-height: 22px;\n  font-size: 14px;\n  color: var(--charcoal-text3);\n`\n\nexport const AssistiveText = styled.p<{ invalid: boolean }>`\n  font-size: 14px;\n  line-height: 22px;\n  margin-top: 4px;\n  margin-bottom: -4px;\n  color: ${(p) => `var(--charcoal-${p.invalid ? `assertive` : `text2`})`};\n`\n","import { useTextField } from '@react-aria/textfield'\nimport { useVisuallyHidden } from '@react-aria/visually-hidden'\nimport { forwardRef, useCallback, useEffect, useRef, useState } from 'react'\nimport styled, { css } from 'styled-components'\nimport { FieldLabelProps } from '../FieldLabel'\nimport { countCodePointsInString, mergeRefs } from '../../_lib'\nimport { ReactAreaUseTextFieldCompat } from '../../_lib/compat'\nimport { AssistiveText, TextFieldLabel } from '../TextField'\nimport { useFocusWithClick } from '../TextField/useFocusWithClick'\n\ntype DOMProps = Omit<\n  React.TextareaHTMLAttributes<HTMLTextAreaElement>,\n  // react-ariaのhookは、onChangeが`(v: string) => void`想定\n  | 'onChange'\n  // ReactAreaUseTextFieldCompatに書いてあるような事情で、ここにあるイベントハンドラの型をゆるめる\n  | keyof ReactAreaUseTextFieldCompat\n>\n\nexport interface TextAreaProps\n  extends Pick<FieldLabelProps, 'label' | 'requiredText' | 'subLabel'>,\n    DOMProps,\n    ReactAreaUseTextFieldCompat {\n  readonly autoHeight?: boolean\n  readonly rows?: number\n\n  // <input> 要素は number とか string[] もありうるが、今はこれしか想定してない\n  readonly defaultValue?: string\n  readonly value?: string\n  readonly onChange?: (value: string) => void\n\n  // react-ariaの型定義のせいでHTMLTextAreaElementにできない\n  readonly onKeyDown?: (event: React.KeyboardEvent<Element>) => void\n  readonly onFocus?: (event: React.FocusEvent<Element>) => void\n  readonly onBlur?: (event: React.FocusEvent<Element>) => void\n\n  readonly showCount?: boolean\n  readonly showLabel?: boolean\n  readonly assistiveText?: string\n  readonly invalid?: boolean\n}\n\nconst TextArea = forwardRef<HTMLTextAreaElement, TextAreaProps>(\n  function TextAreaInner({ onChange, ...props }, forwardRef) {\n    const {\n      className,\n      showCount = false,\n      showLabel = false,\n      label,\n      requiredText,\n      subLabel,\n      disabled = false,\n      required,\n      invalid = false,\n      assistiveText,\n      maxLength,\n      autoHeight = false,\n      rows: initialRows = 4,\n    } = props\n\n    const { visuallyHiddenProps } = useVisuallyHidden()\n    const textareaRef = useRef<HTMLTextAreaElement>(null)\n    const ariaRef = useRef<HTMLTextAreaElement>(null)\n    const [count, setCount] = useState(\n      countCodePointsInString(props.value ?? '')\n    )\n    const [rows, setRows] = useState(initialRows)\n\n    const syncHeight = useCallback(\n      (textarea: HTMLTextAreaElement) => {\n        const rows = (`${textarea.value}\\n`.match(/\\n/gu)?.length ?? 0) || 1\n        setRows(initialRows <= rows ? rows : initialRows)\n      },\n      [initialRows]\n    )\n\n    const nonControlled = props.value === undefined\n    const handleChange = useCallback(\n      (value: string) => {\n        const count = countCodePointsInString(value)\n        if (maxLength !== undefined && count > maxLength) {\n          return\n        }\n        if (nonControlled) {\n          setCount(count)\n        }\n        if (autoHeight && textareaRef.current !== null) {\n          syncHeight(textareaRef.current)\n        }\n        onChange?.(value)\n      },\n      [autoHeight, maxLength, nonControlled, onChange, syncHeight]\n    )\n\n    useEffect(() => {\n      setCount(countCodePointsInString(props.value ?? ''))\n    }, [props.value])\n\n    const { inputProps, labelProps, descriptionProps, errorMessageProps } =\n      useTextField(\n        {\n          inputElementType: 'textarea',\n          isDisabled: disabled,\n          isRequired: required,\n          validationState: invalid ? 'invalid' : 'valid',\n          description: !invalid && assistiveText,\n          errorMessage: invalid && assistiveText,\n          onChange: handleChange,\n          ...props,\n        },\n        ariaRef\n      )\n\n    useEffect(() => {\n      if (autoHeight && textareaRef.current !== null) {\n        syncHeight(textareaRef.current)\n      }\n    }, [autoHeight, syncHeight])\n\n    const containerRef = useRef(null)\n\n    useFocusWithClick(containerRef, ariaRef)\n\n    return (\n      <TextFieldRoot className={className} isDisabled={disabled}>\n        <TextFieldLabel\n          label={label}\n          requiredText={requiredText}\n          required={required}\n          subLabel={subLabel}\n          {...labelProps}\n          {...(!showLabel ? visuallyHiddenProps : {})}\n        />\n        <StyledTextareaContainer\n          ref={containerRef}\n          invalid={invalid}\n          rows={showCount ? rows + 1 : rows}\n          aria-disabled={disabled === true ? 'true' : undefined}\n        >\n          <StyledTextarea\n            ref={mergeRefs(textareaRef, forwardRef, ariaRef)}\n            rows={rows}\n            noBottomPadding={showCount}\n            {...inputProps}\n          />\n          {showCount && (\n            <MultiLineCounter>\n              {maxLength !== undefined ? `${count}/${maxLength}` : count}\n            </MultiLineCounter>\n          )}\n        </StyledTextareaContainer>\n        {assistiveText != null && assistiveText.length !== 0 && (\n          <AssistiveText\n            invalid={invalid}\n            {...(invalid ? errorMessageProps : descriptionProps)}\n          >\n            {assistiveText}\n          </AssistiveText>\n        )}\n      </TextFieldRoot>\n    )\n  }\n)\n\nexport default TextArea\n\nconst TextFieldRoot = styled.div<{ isDisabled: boolean }>`\n  display: flex;\n  flex-direction: column;\n\n  ${(p) => p.isDisabled && { opacity: p.theme.elementEffect.disabled.opacity }}\n`\n\nconst StyledTextareaContainer = styled.div<{ rows: number; invalid: boolean }>`\n  position: relative;\n  overflow: hidden;\n\n  color: var(--charcoal-text2);\n  background-color: var(--charcoal-surface3);\n  border-radius: 4px;\n  transition: 0.2s background-color, 0.2s box-shadow;\n\n  ${({ rows }) => css`\n    height: calc(22px * ${rows} + 18px);\n  `};\n\n  :not([aria-disabled]):hover,\n  [aria-disabled='false']:hover {\n    background-color: var(--charcoal-surface3-hover);\n  }\n  :focus-within {\n    outline: none;\n    box-shadow: 0 0 0 4px\n      ${(p) => (p.invalid ? `rgba(255,43,0,0.32)` : `rgba(0, 150, 250, 0.32);`)};\n  }\n\n  ${(p) =>\n    p.invalid &&\n    css`\n      box-shadow: 0 0 0 4px rgba(255, 43, 0, 0.32);\n    `}\n`\n\nconst StyledTextarea = styled.textarea<{ noBottomPadding: boolean }>`\n  border: none;\n  outline: none;\n  resize: none;\n  font-family: inherit;\n  color: inherit;\n  box-sizing: border-box;\n\n  /* Prevent zooming for iOS Safari */\n  transform-origin: top left;\n  transform: scale(0.875);\n  width: calc(100% / 0.875);\n  font-size: calc(14px / 0.875);\n  line-height: calc(22px / 0.875);\n  padding: calc(9px / 0.875) calc(8px / 0.875)\n    ${(p) => (p.noBottomPadding ? 0 : '')};\n\n  ${({ rows = 1, noBottomPadding }) => css`\n    height: calc(22px / 0.875 * ${rows} + ${noBottomPadding ? 9 : 20}px);\n  `};\n\n  /* Display box-shadow for iOS Safari */\n  appearance: none;\n\n  background: none;\n\n  &::placeholder {\n    color: var(--charcoal-text3);\n  }\n`\n\nconst MultiLineCounter = styled.span`\n  position: absolute;\n  bottom: 9px;\n  right: 8px;\n\n  line-height: 22px;\n  font-size: 14px;\n  color: var(--charcoal-text3);\n`\n","import { forwardRef } from 'react'\nimport * as React from 'react'\nimport styled, { css } from 'styled-components'\nimport { useDialog } from '@react-aria/dialog'\nimport { columnSystem, COLUMN_UNIT, GUTTER_UNIT } from '@charcoal-ui/foundation'\nimport { unreachable } from '../../../_lib'\nimport { maxWidth } from '@charcoal-ui/utils'\nimport { animated } from 'react-spring'\nimport { useForwardedRef } from '../../../_lib/useForwardedRef'\nimport { Size, BottomSheet } from '..'\n\nexport const Dialog = forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof AnimatedStyledDialogDiv>\n>(function Dialog(props, forwardRef) {\n  const ref = useForwardedRef(forwardRef)\n  const { dialogProps } = useDialog(\n    {\n      role: 'dialog',\n    },\n    ref\n  )\n\n  return (\n    <AnimatedStyledDialogDiv\n      {...props}\n      role={dialogProps.role}\n      tabIndex={dialogProps.tabIndex}\n      aria-labelledby={dialogProps['aria-labelledby']}\n      onBlur={dialogProps.onBlur}\n      ref={ref}\n    />\n  )\n})\n\nconst AnimatedStyledDialogDiv = animated(styled.div<{\n  size: Size\n  bottomSheet: BottomSheet\n}>`\n  margin: auto;\n  position: relative;\n  height: fit-content;\n  width: ${(p) => {\n    switch (p.size) {\n      case 'S': {\n        return columnSystem(3, COLUMN_UNIT, GUTTER_UNIT) + GUTTER_UNIT * 2\n      }\n      case 'M': {\n        return columnSystem(4, COLUMN_UNIT, GUTTER_UNIT) + GUTTER_UNIT * 2\n      }\n      case 'L': {\n        return columnSystem(6, COLUMN_UNIT, GUTTER_UNIT) + GUTTER_UNIT * 2\n      }\n      default: {\n        return unreachable(p.size)\n      }\n    }\n  }}px;\n\n  background-color: ${({ theme }) => theme.color.background1};\n  border-radius: 24px;\n\n  @media ${({ theme }) => maxWidth(theme.breakpoint.screen1)} {\n    max-width: 440px;\n    width: calc(100% - 48px);\n    ${(p) =>\n      p.bottomSheet !== false &&\n      css`\n        max-width: unset;\n        width: 100%;\n        border-radius: 0;\n        margin: auto 0 0 0;\n        ${p.bottomSheet === 'full' &&\n        css`\n          min-height: 100%;\n        `}\n      `}\n  }\n  :focus {\n    outline: none;\n  }\n`)\n","import { useContext, forwardRef, memo } from 'react'\nimport * as React from 'react'\nimport {\n  AriaModalOverlayProps,\n  Overlay,\n  useModalOverlay,\n} from '@react-aria/overlays'\nimport styled, { css, useTheme } from 'styled-components'\nimport { theme } from '../../styled'\nimport { AriaDialogProps } from '@react-types/dialog'\nimport { maxWidth } from '@charcoal-ui/utils'\nimport { useMedia } from '@charcoal-ui/styled'\nimport { animated, useTransition, easings } from 'react-spring'\nimport Button, { ButtonProps } from '../Button'\nimport IconButton from '../IconButton'\nimport { useObjectRef } from '@react-aria/utils'\nimport { Dialog } from './Dialog'\nimport { ModalBackgroundContext } from './ModalBackgroundContext'\n\nexport type BottomSheet = boolean | 'full'\nexport type Size = 'S' | 'M' | 'L'\n\nexport type ModalProps = AriaModalOverlayProps &\n  AriaDialogProps & {\n    children: React.ReactNode\n    zIndex?: number\n    title: string\n    size?: Size\n    bottomSheet?: BottomSheet\n    isOpen: boolean\n    onClose: () => void\n    className?: string\n\n    /**\n     * https://github.com/adobe/react-spectrum/issues/3787\n     * Next.jsで使用する際に発生するエラーの一時的な回避策でdocument.bodyを指定する必要がある\n     */\n    portalContainer?: HTMLElement\n  }\n\nconst DEFAULT_Z_INDEX = 10\n\n/**\n * モーダルコンポーネント。\n *\n * @example アプリケーションルートで `<OverlayProvider>` ないし `<CharcoalProvider>` で囲った上で利用する\n * ```tsx\n * import {\n *   OverlayProvider,\n *   Modal,\n *   ModalHeader,\n *   ModalBody,\n *   ModalButtons\n * } from '@charcoal-ui/react'\n *\n * <OverlayProvider>\n *   <App>\n *     <Modal title=\"Title\" isOpen={state.isOpen} onClose={() => state.close()} isDismissable>\n *       <ModalHeader />\n *       <ModalBody>\n *         ...\n *         <ModalButtons>...</ModalButtons>\n *       </ModalBody>\n *     </Modal>\n *   </App>\n * </OverlayProvider>\n * ```\n */\nconst Modal = forwardRef<HTMLDivElement, ModalProps>(function ModalInner(\n  { children, zIndex = DEFAULT_Z_INDEX, portalContainer, ...props },\n  external\n) {\n  const {\n    title,\n    size = 'M',\n    bottomSheet = false,\n    isDismissable,\n    onClose,\n    className,\n    isOpen = false,\n  } = props\n\n  const ref = useObjectRef<HTMLDivElement>(external)\n\n  const { modalProps, underlayProps } = useModalOverlay(\n    props,\n    {\n      close: onClose,\n      isOpen: isOpen,\n      // these props are not used actually.\n      // https://github.com/adobe/react-spectrum/blob/df14e3fb129b94b310f0397a701b83f006b51dfe/packages/%40react-aria/overlays/src/useModalOverlay.ts\n      open: () => {\n        // nope\n      },\n      setOpen: () => {\n        // nope\n      },\n      toggle: () => {\n        // nope\n      },\n    },\n    ref\n  )\n\n  const theme = useTheme()\n  const isMobile = useMedia(maxWidth(theme.breakpoint.screen1)) ?? false\n  const transitionEnabled = isMobile && bottomSheet !== false\n  const showDismiss = !isMobile || bottomSheet !== true\n\n  const transition = useTransition(isOpen, {\n    from: {\n      transform: 'translateY(100%)',\n      backgroundColor: 'rgba(0, 0, 0, 0)',\n      overflow: 'hidden',\n    },\n    enter: {\n      transform: 'translateY(0%)',\n      backgroundColor: 'rgba(0, 0, 0, 0.4)',\n    },\n    update: {\n      overflow: 'auto',\n    },\n    leave: {\n      transform: 'translateY(100%)',\n      backgroundColor: 'rgba(0, 0, 0, 0)',\n      overflow: 'hidden',\n    },\n    config: transitionEnabled\n      ? { duration: 400, easing: easings.easeOutQuart }\n      : { duration: 0 },\n  })\n\n  const bgRef = React.useRef<HTMLElement>(null)\n\n  return transition(\n    ({ backgroundColor, overflow, transform }, item) =>\n      item && (\n        <Overlay portalContainer={portalContainer}>\n          <ModalBackground\n            ref={bgRef}\n            zIndex={zIndex}\n            {...underlayProps}\n            style={transitionEnabled ? { backgroundColor, overflow } : {}}\n            $bottomSheet={bottomSheet}\n          >\n            <ModalBackgroundContext.Provider value={bgRef.current}>\n              <Dialog\n                ref={ref}\n                {...modalProps}\n                style={transitionEnabled ? { transform } : {}}\n                size={size}\n                bottomSheet={bottomSheet}\n                className={className}\n              >\n                <ModalContext.Provider\n                  value={{\n                    titleProps: {},\n                    title,\n                    close: onClose,\n                    showDismiss,\n                    bottomSheet,\n                  }}\n                >\n                  {children}\n                  {isDismissable === true && (\n                    <ModalCrossButton\n                      size=\"S\"\n                      icon=\"24/Close\"\n                      onClick={onClose}\n                    />\n                  )}\n                </ModalContext.Provider>\n              </Dialog>\n            </ModalBackgroundContext.Provider>\n          </ModalBackground>\n        </Overlay>\n      )\n  )\n})\n\nexport default memo(Modal)\n\nexport const ModalContext = React.createContext<{\n  /**\n   * @deprecated\n   */\n  titleProps: React.HTMLAttributes<HTMLElement>\n  title: string\n  close?: () => void\n  showDismiss: boolean\n  bottomSheet: BottomSheet\n}>({\n  titleProps: {},\n  title: '',\n  close: undefined,\n  showDismiss: true,\n  bottomSheet: false,\n})\n\nconst ModalBackground = animated(styled.div<{\n  zIndex: number\n  $bottomSheet: BottomSheet\n}>`\n  z-index: ${({ zIndex }) => zIndex};\n  overflow: auto;\n  display: flex;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: -webkit-fill-available;\n  width: -moz-available;\n  height: 100%;\n  justify-content: center;\n  padding: 40px 0;\n  box-sizing: border-box;\n\n  background-color: ${({ theme }) => theme.color.surface4};\n\n  @media ${({ theme }) => maxWidth(theme.breakpoint.screen1)} {\n    ${(p) =>\n      p.$bottomSheet !== false &&\n      css`\n        padding: 0;\n      `}\n  }\n`)\n\nconst ModalCrossButton = styled(IconButton)`\n  position: absolute;\n  top: 8px;\n  right: 8px;\n\n  ${theme((o) => [o.font.text3.hover.press])}\n`\n\nexport function ModalTitle(props: React.HTMLAttributes<HTMLHeadingElement>) {\n  const { titleProps, title } = useContext(ModalContext)\n  return (\n    <ModalHeading {...titleProps} {...props}>\n      {title}\n    </ModalHeading>\n  )\n}\n\nconst ModalHeading = styled.h3`\n  margin: 0;\n  font-weight: inherit;\n  font-size: inherit;\n`\n\nexport function ModalDismissButton({ children, ...props }: ButtonProps) {\n  const { close, showDismiss } = useContext(ModalContext)\n\n  if (!showDismiss) {\n    return null\n  }\n\n  return (\n    <Button {...props} onClick={close} fullWidth>\n      {children}\n    </Button>\n  )\n}\n","import { BottomSheet, ModalContext, ModalTitle } from '.'\nimport styled, { css } from 'styled-components'\nimport { theme } from '../../styled'\nimport { useContext } from 'react'\nimport { maxWidth } from '@charcoal-ui/utils'\n\nexport function ModalHeader() {\n  const modalCtx = useContext(ModalContext)\n  return (\n    <ModalHeaderRoot $bottomSheet={modalCtx.bottomSheet}>\n      <StyledModalTitle />\n    </ModalHeaderRoot>\n  )\n}\n\nconst ModalHeaderRoot = styled.div<{\n  $bottomSheet: BottomSheet\n}>`\n  height: 64px;\n  display: grid;\n  align-content: center;\n  justify-content: center;\n  @media ${({ theme }) => maxWidth(theme.breakpoint.screen1)} {\n    ${(p) =>\n      p.$bottomSheet !== false &&\n      css`\n        height: 48px;\n      `}\n  }\n`\n\nconst StyledModalTitle = styled(ModalTitle)`\n  ${theme((o) => [o.font.text1, o.typography(16).bold])}\n`\n\nexport const ModalAlign = styled.div`\n  ${theme((o) => [o.padding.horizontal(16)])}\n`\n\nexport const ModalBody = styled.div`\n  ${theme((o) => [o.padding.bottom(40)])}\n`\n\nexport const ModalButtons = styled.div`\n  display: grid;\n  grid-auto-flow: row;\n  grid-row-gap: 8px;\n\n  ${theme((o) => [o.padding.horizontal(16).top(16)])}\n`\n","import { forwardRef, useImperativeHandle, useRef, memo } from 'react'\nimport styled, { keyframes } from 'styled-components'\n\nexport type LoadingSpinnerProps = {\n  readonly size?: number\n  readonly padding?: number\n  readonly transparent?: boolean\n  readonly className?: string\n}\n\nconst LoadingSpinner = forwardRef<HTMLDivElement, LoadingSpinnerProps>(\n  function LoadingSpinnerInner(\n    { size = 48, padding = 16, transparent = false, className },\n    ref\n  ) {\n    return (\n      <LoadingSpinnerRoot\n        size={size}\n        padding={padding}\n        transparent={transparent}\n        className={className}\n        ref={ref}\n      >\n        <LoadingSpinnerIcon />\n      </LoadingSpinnerRoot>\n    )\n  }\n)\n\nexport default memo(LoadingSpinner)\n\nconst LoadingSpinnerRoot = styled.div.attrs({ role: 'progressbar' })<{\n  size: number\n  padding: number\n  transparent: boolean\n}>`\n  box-sizing: content-box;\n  margin: auto;\n  padding: ${(props) => props.padding}px;\n  border-radius: 8px;\n  font-size: ${(props) => props.size}px;\n  width: ${(props) => props.size}px;\n  height: ${(props) => props.size}px;\n  opacity: 0.84;\n  color: var(--charcoal-text4);\n  background-color: ${({ transparent }) =>\n    `var(--charcoal-${transparent ? 'transparent' : 'background1'})`};\n`\n\nconst scaleOut = keyframes`\n  from {\n    transform: scale(0);\n    opacity: 1;\n  }\n\n  to {\n    transform: scale(1);\n    opacity: 0;\n  }\n`\n\nconst Icon = styled.div.attrs({ role: 'presentation' })<{ once: boolean }>`\n  width: 1em;\n  height: 1em;\n  border-radius: 1em;\n  background-color: currentColor;\n  animation: ${scaleOut} 1s both ease-out;\n  animation-iteration-count: ${(p) => (p.once ? 1 : 'infinite')};\n\n  &[data-reset-animation] {\n    animation: none;\n  }\n`\n\ninterface Props {\n  once?: boolean\n}\n\nexport interface LoadingSpinnerIconHandler {\n  restart(): void\n}\n\nexport const LoadingSpinnerIcon = forwardRef<LoadingSpinnerIconHandler, Props>(\n  function LoadingSpinnerIcon({ once = false }, ref) {\n    const iconRef = useRef<HTMLDivElement>(null)\n\n    useImperativeHandle(ref, () => ({\n      restart: () => {\n        if (!iconRef.current) {\n          return\n        }\n        iconRef.current.dataset.resetAnimation = 'true'\n        // Force reflow hack!\n        void iconRef.current.offsetWidth\n        delete iconRef.current.dataset.resetAnimation\n      },\n    }))\n\n    return <Icon ref={iconRef} once={once} />\n  }\n)\n","import { RefObject, useContext, useRef } from 'react'\nimport { ReactNode } from 'react'\nimport { DismissButton, Overlay, usePopover } from '@react-aria/overlays'\nimport styled from 'styled-components'\nimport { theme } from '../../../styled'\nimport { ModalBackgroundContext } from '../../Modal/ModalBackgroundContext'\nimport { usePreventScroll } from './usePreventScroll'\n\nexport type PopoverProps = {\n  isOpen: boolean\n  onClose: () => void\n  children: ReactNode\n  triggerRef: RefObject<Element>\n  popoverRef?: RefObject<HTMLDivElement>\n}\n\nconst _empty = () => null\n\n/**\n * 画面の全面に動的に開くことができるコンテナ要素\n * 外の要素をクリックしたり、内部からフォーカスを移動した場合に自動的に閉じる\n *\n * triggerRefの付近に画面内に収まるように表示される\n */\nexport default function Popover(props: PopoverProps) {\n  const defaultPopoverRef = useRef<HTMLDivElement>(null)\n  const finalPopoverRef =\n    props.popoverRef === undefined ? defaultPopoverRef : props.popoverRef\n  const { popoverProps, underlayProps } = usePopover(\n    {\n      triggerRef: props.triggerRef,\n      popoverRef: finalPopoverRef,\n      containerPadding: 16,\n    },\n    {\n      close: props.onClose,\n      isOpen: props.isOpen,\n      // never used\n      open: _empty,\n      setOpen: _empty,\n      toggle: _empty,\n    }\n  )\n\n  const modalBackground = useContext(ModalBackgroundContext)\n  usePreventScroll(modalBackground, props.isOpen)\n\n  if (!props.isOpen) return null\n\n  return (\n    <Overlay portalContainer={document.body}>\n      <div\n        {...underlayProps}\n        style={{\n          position: 'fixed',\n          zIndex:\n            typeof popoverProps.style?.zIndex === 'number'\n              ? popoverProps.style.zIndex - 1\n              : 99999,\n          inset: 0,\n        }}\n      />\n      <DropdownPopoverDiv {...popoverProps} ref={finalPopoverRef}>\n        <DismissButton onDismiss={() => props.onClose()} />\n        {props.children}\n        <DismissButton onDismiss={() => props.onClose()} />\n      </DropdownPopoverDiv>\n    </Overlay>\n  )\n}\n\nconst DropdownPopoverDiv = styled.div`\n  margin: 4px 0;\n  list-style: none;\n  overflow: auto;\n  max-height: inherit;\n\n  ${theme((o) => [\n    o.bg.background1,\n    o.border.default,\n    o.borderRadius(8),\n    o.padding.vertical(8),\n  ])}\n`\n","import { useRef } from 'react'\nimport styled from 'styled-components'\nimport { MenuListContext } from './MenuListContext'\nimport { getValuesRecursive } from './internals/getValuesRecursive'\nimport MenuItem from '../MenuItem'\nimport { Divider } from '../Divider'\nimport MenuItemGroup from '../MenuItemGroup'\n\ntype MenuListChild = React.ReactElement<\n  typeof MenuItem | typeof MenuItemGroup | typeof Divider\n>\n\nexport type MenuListChildren = MenuListChild | MenuListChild[]\n\nexport type MenuListProps = {\n  children: MenuListChildren\n  value?: string\n  onChange?: (v: string) => void\n}\n\n/**\n * 上下キーでフォーカス移動でき、エンターキーで選択できるリストの項目\n * 基本的に`<MenuItem>`, `<MenuGroup>`と合わせて使用する\n */\nexport default function MenuList(props: MenuListProps) {\n  const root = useRef(null)\n  const values: string[] = []\n  getValuesRecursive(props.children, values)\n\n  return (\n    <StyledUl ref={root}>\n      <MenuListContext.Provider\n        value={{\n          value: props.value ?? '',\n          root,\n          values,\n          setValue: (v) => {\n            props.onChange?.(v)\n          },\n        }}\n      >\n        {props.children}\n      </MenuListContext.Provider>\n    </StyledUl>\n  )\n}\n\nconst StyledUl = styled.ul`\n  padding: 0;\n  margin: 0;\n`\n","import { ReactNode, useState, useRef } from 'react'\nimport styled from 'styled-components'\nimport { disabledSelector } from '@charcoal-ui/utils'\nimport Icon from '../Icon'\nimport FieldLabel from '../FieldLabel'\nimport { theme } from '../../styled'\nimport { DropdownPopover } from './DropdownPopover'\nimport { findPreviewRecursive } from './utils/findPreviewRecursive'\nimport MenuList, { MenuListChildren } from './MenuList'\n\nexport type DropdownSelectorProps = {\n  label: string\n  value: string\n  disabled?: boolean\n  placeholder?: string\n  showLabel?: boolean\n  invalid?: boolean\n  assistiveText?: string\n  required?: boolean\n  requiredText?: string\n  subLabel?: ReactNode\n  children: MenuListChildren\n  onChange: (value: string) => void\n}\n\nconst defaultRequiredText = '*必須'\n\nexport default function DropdownSelector(props: DropdownSelectorProps) {\n  const triggerRef = useRef<HTMLButtonElement>(null)\n  const [isOpen, setIsOpen] = useState(false)\n  const preview = findPreviewRecursive(props.children, props.value)\n\n  return (\n    <DropdownSelectorRoot aria-disabled={props.disabled}>\n      {props.showLabel === true && (\n        <DropdownFieldLabel\n          label={props.label}\n          required={props.required}\n          requiredText={props.requiredText ?? defaultRequiredText}\n          subLabel={props.subLabel}\n        />\n      )}\n      <DropdownButton\n        invalid={props.invalid}\n        disabled={props.disabled}\n        onClick={() => {\n          if (props.disabled === true) return\n          setIsOpen(true)\n        }}\n        ref={triggerRef}\n        type=\"button\"\n      >\n        <DropdownButtonText>\n          {props.placeholder !== undefined && preview === undefined\n            ? props.placeholder\n            : preview}\n        </DropdownButtonText>\n        <DropdownButtonIcon name=\"16/Menu\" />\n      </DropdownButton>\n      {isOpen && (\n        <DropdownPopover\n          isOpen={isOpen}\n          onClose={() => setIsOpen(false)}\n          triggerRef={triggerRef}\n          value={props.value}\n        >\n          <MenuList\n            value={props.value}\n            onChange={(v) => {\n              props.onChange(v)\n              setIsOpen(false)\n            }}\n          >\n            {props.children}\n          </MenuList>\n        </DropdownPopover>\n      )}\n      {props.assistiveText !== undefined && (\n        <AssertiveText invalid={props.invalid}>\n          {props.assistiveText}\n        </AssertiveText>\n      )}\n    </DropdownSelectorRoot>\n  )\n}\n\nconst DropdownSelectorRoot = styled.div`\n  display: inline-block;\n  width: 100%;\n\n  ${disabledSelector} {\n    cursor: default;\n    ${theme((o) => o.disabled)}\n  }\n`\n\nconst DropdownFieldLabel = styled(FieldLabel)`\n  width: 100%;\n\n  ${theme((o) => o.margin.bottom(8))}\n`\n\nconst DropdownButton = styled.button<{ invalid?: boolean }>`\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n\n  height: 40px;\n  width: 100%;\n  box-sizing: border-box;\n  border: none;\n  cursor: pointer;\n\n  ${disabledSelector} {\n    cursor: default;\n  }\n\n  ${({ invalid }) =>\n    theme((o) => [\n      o.padding.horizontal(8),\n      o.outline.default.focus,\n      o.bg.surface3,\n      o.borderRadius(4),\n      invalid === true && o.outline.assertive,\n    ])}\n`\n\nconst DropdownButtonText = styled.span`\n  text-align: left;\n\n  ${theme((o) => [o.typography(14), o.font.text2])}\n`\n\nconst DropdownButtonIcon = styled(Icon)`\n  ${theme((o) => [o.font.text2])}\n`\n\nconst AssertiveText = styled.div<{ invalid?: boolean }>`\n  ${({ invalid }) =>\n    theme((o) => [\n      o.typography(14),\n      o.margin.top(8),\n      invalid === true ? o.font.assertive : o.font.text2,\n    ])}\n`\n","import { ReactNode } from 'react'\nimport styled from 'styled-components'\nimport { theme } from '../../../styled'\n\nexport type CustomJSXElement =\n  | keyof JSX.IntrinsicElements\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | React.JSXElementConstructor<any>\n\nexport type ListItemProps<T extends CustomJSXElement = 'div'> = {\n  children?: ReactNode\n  as?: T\n} & Omit<React.ComponentProps<T>, 'children'>\n\n/**\n * リストのある要素を示すコンポーネント\n *\n * asを用いて拡張することができる\n * @example\n * ```\n * <ListItem as=\"a\" href=\"#\">Link</ListItem>\n * <ListItem as={NextLink} href=\"#\">NextLink</ListItem>\n * ```\n */\nexport default function ListItem<T extends CustomJSXElement = 'div'>(\n  props: ListItemProps<T>\n) {\n  const { children, ...rest } = props\n  return (\n    <StyledLi role=\"option\">\n      <ItemDiv {...rest}>{props.children}</ItemDiv>\n    </StyledLi>\n  )\n}\n\nconst StyledLi = styled.li`\n  list-style: none;\n`\n\nconst ItemDiv = styled.div`\n  display: flex;\n  align-items: center;\n  min-height: 40px;\n  cursor: pointer;\n  outline: none;\n\n  ${theme((o) => [o.padding.horizontal(16), o.disabled])}\n\n  &[aria-disabled=\"true\"] {\n    cursor: default;\n  }\n\n  :hover,\n  :focus,\n  :focus-within {\n    ${theme((o) => [o.bg.surface3])}\n  }\n`\n","import styled from 'styled-components'\nimport MenuItem, { MenuItemProps } from './MenuItem'\nimport { MenuListContext } from './MenuList/MenuListContext'\nimport { useContext } from 'react'\nimport { theme } from '../../styled'\nimport Icon from '../Icon'\n\nexport type DropdownMenuItemProps = Omit<MenuItemProps<'div'>, 'as'>\n\n/**\n * DropdownSelectorの選択肢として使うMenuItem\n */\nexport default function DropdownMenuItem(props: DropdownMenuItemProps) {\n  const { value: ctxValue } = useContext(MenuListContext)\n  const isSelected = props.value === ctxValue\n  const { children, ...rest } = props\n\n  return (\n    <MenuItem {...rest}>\n      {isSelected && <Text2ColorIcon name=\"16/Check\" />}\n      <StyledSpan isSelected={isSelected}>{props.children}</StyledSpan>\n    </MenuItem>\n  )\n}\n\n/**\n * アイコンがない時を考慮して20px（16pxのwidthと4pxのgap）の余白をとる\n */\nconst StyledSpan = styled.span<{ isSelected?: boolean }>`\n  ${theme((o) => [o.typography(14), o.font.text2])};\n  display: flex;\n  align-items: center;\n  width: 100%;\n  margin-left: ${({ isSelected }) => (isSelected === true ? 0 : 20)}px;\n`\n\nconst Text2ColorIcon = styled(Icon)`\n  ${theme((o) => [o.font.text2])}\n  padding-right: 4px;\n`\n","import styled from 'styled-components'\nimport MenuItem from '../MenuItem'\nimport { Divider } from '../Divider'\n\ntype MenuItemGroupChild = React.ReactElement<typeof MenuItem | typeof Divider>\n\nexport type MenuItemGroupProps = {\n  text: string\n  children: MenuItemGroupChild | MenuItemGroupChild[]\n}\n\n/**\n * 項目のリストを分類する見出しをつけるコンテナ要素\n */\nexport default function MenuItemGroup(props: MenuItemGroupProps) {\n  return (\n    <StyledLi role=\"presentation\">\n      <TextSpan>{props.text}</TextSpan>\n      <StyledUl role=\"group\">{props.children}</StyledUl>\n    </StyledLi>\n  )\n}\n\nconst TextSpan = styled.span`\n  display: block;\n  color: ${({ theme }) => theme.color.text3};\n  font-size: 12px;\n  font-weight: bold;\n  padding: 12px 0 8px 16px;\n`\n\nconst StyledUl = styled.ul`\n  padding-left: 0;\n  margin: 0;\n  box-sizing: border-box;\n  list-style: none;\n  overflow: hidden;\n`\n\nconst StyledLi = styled.li`\n  display: block;\n`\n","import { ReactNode, forwardRef, memo, useMemo, useRef } from 'react'\nimport * as React from 'react'\nimport { useRadioGroupState } from 'react-stately'\nimport {\n  AriaRadioGroupProps,\n  AriaRadioProps,\n  useRadio,\n  useRadioGroup,\n} from '@react-aria/radio'\nimport styled from 'styled-components'\nimport { disabledSelector } from '@charcoal-ui/utils'\n\nimport { RadioProvider, useRadioContext } from './RadioGroupContext'\nimport { theme } from '../../styled'\n\ntype SegmentedControlItem = {\n  label: React.ReactNode\n  value: string\n  disabled?: boolean\n}\n\nexport type SegmentedControlProps = {\n  readonly id?: string\n  readonly name?: string\n  readonly disabled?: boolean\n  readonly readonly?: boolean\n  readonly required?: boolean\n  readonly className?: string\n\n  readonly value?: string\n  readonly defaultValue?: string\n\n  readonly data: string[] | SegmentedControlItem[]\n\n  readonly onChange?: (value: string) => void\n}\n\nconst SegmentedControl = forwardRef<HTMLDivElement, SegmentedControlProps>(\n  function SegmentedControlInner(props, ref) {\n    const ariaRadioGroupProps = useMemo<AriaRadioGroupProps>(\n      () => ({\n        ...props,\n        isDisabled: props.disabled,\n        isReadOnly: props.readonly,\n        isRequired: props.required,\n        'aria-label': props.name,\n      }),\n      [props]\n    )\n    const state = useRadioGroupState(ariaRadioGroupProps)\n    const { radioGroupProps } = useRadioGroup(ariaRadioGroupProps, state)\n    const segmentedControlItems = useMemo<SegmentedControlItem[]>(() => {\n      return props.data.map((d) =>\n        typeof d === 'string' ? { value: d, label: d } : d\n      )\n    }, [props.data])\n\n    return (\n      <SegmentedControlRoot\n        ref={ref}\n        {...radioGroupProps}\n        className={props.className}\n      >\n        <RadioProvider value={state}>\n          {segmentedControlItems.map((item) => (\n            <Segmented\n              key={item.value}\n              value={item.value}\n              disabled={item.disabled}\n            >\n              {item.label}\n            </Segmented>\n          ))}\n        </RadioProvider>\n      </SegmentedControlRoot>\n    )\n  }\n)\n\nexport default memo(SegmentedControl)\n\ntype RadioProps = {\n  value: string\n  disabled?: boolean\n  children?: ReactNode\n}\n\nconst Segmented = (props: RadioProps) => {\n  const state = useRadioContext()\n  const ref = useRef<HTMLInputElement>(null)\n  const ariaRadioProps = useMemo<AriaRadioProps>(\n    () => ({\n      value: props.value,\n      isDisabled: props.disabled,\n      children: props.children,\n    }),\n    [props]\n  )\n\n  const { inputProps, isDisabled, isSelected } = useRadio(\n    ariaRadioProps,\n    state,\n    ref\n  )\n\n  return (\n    <SegmentedRoot\n      aria-disabled={isDisabled || state.isReadOnly}\n      checked={isSelected}\n    >\n      <SegmentedInput {...inputProps} ref={ref} />\n      <RadioLabel>\n        <SegmentedLabelInner>{props.children}</SegmentedLabelInner>\n      </RadioLabel>\n    </SegmentedRoot>\n  )\n}\n\nconst SegmentedControlRoot = styled.div`\n  display: inline-flex;\n  align-items: center;\n\n  ${theme((o) => [o.bg.surface3, o.borderRadius(16)])}\n`\n\nconst SegmentedRoot = styled.label<{ checked?: boolean }>`\n  position: relative;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  height: 32px;\n\n  ${disabledSelector} {\n    cursor: default;\n  }\n\n  ${({ checked }) =>\n    theme((o) => [\n      o.padding.horizontal(16),\n      o.borderRadius(16),\n      o.disabled,\n      checked === true && o.bg.brand,\n      checked === true ? o.font.text5 : o.font.text2,\n    ])}\n`\nconst SegmentedInput = styled.input`\n  position: absolute;\n\n  height: 0px;\n  width: 0px;\n  padding: 0;\n  margin: 0;\n\n  appearance: none;\n  box-sizing: border-box;\n  overflow: hidden;\n  white-space: nowrap;\n  opacity: 0;\n`\n\nconst RadioLabel = styled.div`\n  background: transparent;\n  display: flex;\n  align-items: center;\n  height: 22px;\n`\nconst SegmentedLabelInner = styled.div`\n  ${theme((o) => [o.typography(14)])}\n`\n","import { forwardRef, memo, useMemo, ComponentPropsWithoutRef } from 'react'\nimport { useObjectRef } from '@react-aria/utils'\nimport styled, { css } from 'styled-components'\nimport { theme } from '../../styled'\nimport { disabledSelector, px } from '@charcoal-ui/utils'\nimport { AriaButtonProps, useButton } from '@react-aria/button'\nimport Icon from '../Icon'\n\nconst sizeMap = {\n  S: 32,\n  M: 40,\n}\n\nexport type TagItemProps = {\n  label: string\n  translatedLabel?: string\n  bgColor?: string\n  bgImage?: string\n  status?: 'default' | 'active' | 'inactive'\n  size?: keyof typeof sizeMap\n  disabled?: boolean\n  className?: string\n} & Pick<ComponentPropsWithoutRef<'a'>, 'href' | 'target' | 'rel' | 'onClick'>\n\nconst TagItem = forwardRef<HTMLAnchorElement, TagItemProps>(\n  function TagItemInner(\n    {\n      label,\n      translatedLabel,\n      bgColor = '#7ACCB1',\n      bgImage,\n      size = 'M',\n      disabled,\n      status = 'default',\n      className,\n      ...props\n    },\n    _ref\n  ) {\n    const ref = useObjectRef(_ref)\n    const ariaButtonProps = useMemo<AriaButtonProps<'a'>>(\n      () => ({\n        elementType: 'a',\n        isDisabled: disabled,\n        ...props,\n      }),\n      [disabled, props]\n    )\n\n    const { buttonProps } = useButton(ariaButtonProps, ref)\n    const hasTranslatedLabel =\n      translatedLabel !== undefined && translatedLabel.length > 0\n\n    return (\n      <TagItemRoot\n        ref={ref}\n        size={hasTranslatedLabel ? 'M' : size}\n        status={status}\n        {...buttonProps}\n        className={className}\n      >\n        <Background bgColor={bgColor} bgImage={bgImage} status={status} />\n\n        <Inner>\n          <LabelWrapper isTranslate={hasTranslatedLabel}>\n            {hasTranslatedLabel && (\n              <TranslatedLabel>\n                <Label>{translatedLabel}</Label>\n              </TranslatedLabel>\n            )}\n            <Label>{label}</Label>\n          </LabelWrapper>\n          {status === 'active' && <Icon name=\"16/Remove\" />}\n        </Inner>\n      </TagItemRoot>\n    )\n  }\n)\n\nexport default memo(TagItem)\n\ntype TagItemRootProps = Pick<TagItemProps, 'status'> &\n  Required<Pick<TagItemProps, 'size'>>\n\nconst TagItemRoot = styled.a<TagItemRootProps>`\n  isolation: isolate;\n  position: relative;\n  height: ${({ size }) => sizeMap[size]}px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  text-decoration: none;\n  cursor: pointer;\n  overflow: hidden;\n\n  ${({ size, status }) =>\n    theme((o) => [\n      o.outline.default.focus,\n      o.borderRadius(4),\n      status !== 'active' && size === 'M' && o.padding.horizontal(24),\n      status !== 'active' && size === 'S' && o.padding.horizontal(16),\n      status === 'inactive' ? o.font.text2 : o.font.text5,\n      ...(status === 'active' ? [o.padding.left(16), o.padding.right(8)] : []),\n    ])}\n\n  ${disabledSelector} {\n    ${theme((o) => [o.disabled])}\n    cursor: default;\n  }\n`\n\nconst Background = styled.div<\n  Pick<TagItemProps, 'bgColor' | 'bgImage' | 'status'>\n>`\n  position: absolute;\n  z-index: 1;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n\n  background-color: ${({ bgColor }) => bgColor};\n  ${({ status }) => status === 'inactive' && theme((o) => o.bg.surface3)}\n\n  ${({ bgImage }) =>\n    bgImage !== undefined &&\n    css`\n      ${theme((o) => [o.bg.surface4])}\n      &::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-position: center;\n        background-size: cover;\n        background-image: url(${bgImage});\n        mix-blend-mode: overlay;\n      }\n    `}\n`\n\nconst Inner = styled.div`\n  display: inline-flex;\n  gap: ${({ theme }) => px(theme.spacing[8])};\n  align-items: center;\n  z-index: 2;\n`\n\nconst labelCSS = css`\n  ${theme((o) => [o.typography(14).bold])}\n`\nconst translateLabelCSS = css`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  font-size: 10px;\n`\nconst LabelWrapper = styled.div<{ isTranslate?: boolean }>`\n  ${({ isTranslate }) => (isTranslate ?? false ? translateLabelCSS : labelCSS)}\n`\n\nconst Label = styled.span`\n  max-width: 152px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-size: inherit;\n  color: inherit;\n  line-height: inherit;\n`\n\nconst TranslatedLabel = styled.div`\n  ${theme((o) => [o.typography(12).bold])}\n`\n","import { forwardRef, memo, useMemo } from 'react'\nimport * as React from 'react'\nimport styled, { css } from 'styled-components'\nimport { useCheckbox } from '@react-aria/checkbox'\nimport { useObjectRef } from '@react-aria/utils'\nimport { useToggleState } from 'react-stately'\nimport { disabledSelector, px } from '@charcoal-ui/utils'\nimport { theme } from '../../styled'\n\nimport type { AriaCheckboxProps } from '@react-types/checkbox'\nimport Icon from '../Icon'\n\ntype CheckboxLabelProps =\n  | {\n      children: React.ReactNode\n    }\n  | {\n      label: string\n    }\n\nexport type CheckboxProps = CheckboxLabelProps & {\n  readonly id?: string\n  readonly name?: string\n  readonly className?: string\n\n  readonly checked?: boolean\n  readonly defaultChecked?: boolean\n  readonly disabled?: boolean\n  readonly readonly?: boolean\n  readonly invalid?: boolean\n\n  readonly onClick?: () => void\n  readonly onChange?: (isSelected: boolean) => void\n  readonly onBlur?: () => void\n  readonly onFocus?: () => void\n}\n\nconst Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(\n  function CheckboxInner({ invalid = false, ...props }, ref) {\n    const ariaCheckboxProps = useMemo<AriaCheckboxProps>(\n      () => ({\n        ...props,\n        isSelected: props.checked,\n        defaultSelected: props.defaultChecked,\n        validationState: invalid ? 'invalid' : 'valid',\n        // children がいない場合は aria-label をつけないといけない\n        'aria-label': 'children' in props ? undefined : props.label,\n        isDisabled: props.disabled,\n      }),\n      [invalid, props]\n    )\n    const state = useToggleState(ariaCheckboxProps)\n    const objectRef = useObjectRef(ref)\n\n    const { inputProps } = useCheckbox(ariaCheckboxProps, state, objectRef)\n    const isDisabled = (props.disabled ?? false) || (props.readonly ?? false)\n\n    return (\n      <InputRoot aria-disabled={isDisabled} className={props.className}>\n        <CheckboxRoot>\n          <CheckboxInput type=\"checkbox\" {...inputProps} invalid={invalid} />\n          <CheckboxInputOverlay aria-hidden={true} checked={inputProps.checked}>\n            <Icon name=\"24/Check\" unsafeNonGuidelineScale={2 / 3} />\n          </CheckboxInputOverlay>\n        </CheckboxRoot>\n\n        {'children' in props && <InputLabel>{props.children}</InputLabel>}\n      </InputRoot>\n    )\n  }\n)\n\nexport default memo(Checkbox)\n\nconst hiddenCss = css`\n  visibility: hidden;\n`\n\nconst InputRoot = styled.label`\n  position: relative;\n  display: flex;\n\n  cursor: pointer;\n  ${disabledSelector} {\n    cursor: default;\n  }\n\n  gap: ${({ theme }) => px(theme.spacing[4])};\n  ${theme((o) => [o.disabled])}\n`\n\nconst CheckboxRoot = styled.div`\n  position: relative;\n`\n\nconst CheckboxInput = styled.input<{ invalid: boolean }>`\n  &[type='checkbox'] {\n    appearance: none;\n    display: block;\n    cursor: pointer;\n    margin: 0;\n    width: 20px;\n    height: 20px;\n\n    &:checked {\n      ${theme((o) => o.bg.brand.hover.press)}\n    }\n    &:not(:checked) {\n      border-width: 2px;\n      border-style: solid;\n      border-color: ${({ theme }) => theme.color.text4};\n    }\n    ${theme((o) => [o.outline.default.focus, o.borderRadius(4)])}\n    ${(p) => p.invalid && theme((o) => [o.outline.assertive])}\n\n    /* FIXME: o.outline.default.focus の transition に o.bg.brand の transition が打ち消されてしまう */\n    transition: all 0.2s !important;\n  }\n`\n\nconst CheckboxInputOverlay = styled.div<{ checked?: boolean }>`\n  position: absolute;\n  top: -2px;\n  left: -2px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  ${theme((o) => [o.width.px(24), o.height.px(24), o.font.text5])}\n\n  ${({ checked }) => checked !== true && hiddenCss};\n`\n\nconst InputLabel = styled.div`\n  ${theme((o) => [o.font.text2])}\n\n  font-size: 14px;\n  /** checkbox の height が 20px なのでcheckbox と text が揃っているように見せるために行ボックスの高さを 20px にしている */\n  line-height: 20px;\n`\n"],"names":[],"sourceRoot":""}